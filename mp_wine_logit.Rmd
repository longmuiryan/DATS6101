---
title: "Data Science 6101 Project 1 Paper"
author: "by Data Wine'ing"
output:
  html_document:
    code_folding: hide
    number_sections: false
    toc: true
    toc_depth: 2
    toc_float: yes
    includes: 
      before_body: header.html
---

```{css, echo=FALSE}

body {
  color: black;
  background-color: #FFFFF;
}

.list-group-item.active, .list-group-item.active:focus, .list-group-item.active:hover {
    color: #FFFFF;
    background-color: #2A363B;
}
```
 
```{r Preamble, include = F}
# knitr settings 
knitr::opts_chunk$set(fig.width = 12, fig.height = 4,
  warning=FALSE, message=FALSE, echo = FALSE)

# set working directory 
setwd("/Users/perry/Documents/Git/Intro To Data Science/edwinbet")

# load packages 
loadPkg(tidyverse)
loadPkg(regclass)
loadPkg(pROC)
```

```{r functions}
# use this function to conveniently load libraries and work smoothly with knitting
# can add quietly=T option to the require() function
loadPkg = function(pkg, character.only = FALSE) { 
  if (!character.only) { pkg <- as.character(substitute(pkg)) }
  pkg <- ifelse(!character.only, as.character(substitute(pkg)) , pkg)  
  if (!require(pkg,character.only=T, quietly =T)) {  install.packages(substitute(pkg),dep=T); if(!require(pkg,character.only=T)) stop("Package not found") } 
}
loadPkg(knitr)

# unload/detact package when done using it
unloadPkg = function(pkg, character.only = FALSE) { 
  if(!character.only) { pkg <- as.character(substitute(pkg)) } 
  search_item <- paste("package", pkg,sep = ":") 
  while(search_item %in% search()) { detach(search_item, unload = TRUE, character.only = TRUE) } 
}

uzscale <- function(df, append=0, excl=NULL) { 
  #' Standardize dataframe to z scores, safe for non-numeric variables. 
  #' ELo 201904 GWU DATS
  #' @param df The dataframe.
  #' @param append T/F or 0/1. Option to append scaled columns or replace original columns in the dataframe.
  #' @param excl A list c(a,b,"d","ef") of excluded columns, either by their indexes and/or names.
  #' @return The transformed dataframe, appended or replaced with standardized scores. Non-numeric columns will not be appended, or if "replace option" is chosen, the columns will be untouched.
  #' @examples
  #' library("ISLR")
  #' tmp = uzscale( Hitters )
  #' tmp = uzscale( Hitters, 1 )
  #' tmp = uzscale( Hitters, TRUE, c(19,"NewLeague") )

  append = ifelse(append==TRUE || append=="true" || append=="True" || append=="T" || append=="t" || append==1 || append=="1", TRUE, FALSE) # standardize append 
  nmax = length(df)
  if (nmax < 1 || !is.numeric(nmax) ) { return(df) }
  df1 = df
  onames = colnames(df)  # the original column names
  cnames = onames  # the new column names, if needed start with the original ones
  znames = paste("z",cnames, sep="")     # new column names added prefix 'z'. Those are non-numeric will not be used.
  nadd = ifelse(append, nmax, 0) # add to the column index or replace the orig columns
  j=1  # counting index
  for( i in 1:nmax ) {
    if ( is.numeric(df[,i]) && !( i %in% excl || onames[i] %in% excl ) ) { 
      df1[,j+nadd] = scale(df[,i])
      cnames = c(cnames, znames[i])
      j=j+1
    } else if ( !append ) { j=j+1
    } # if append == 1 and (colunm non-numeric or excluded), do not advance j.
  }
  if (append) { colnames(df1) <- cnames }
  return(df1)
}
# sample
# loadPkg(ISLR)
# HittersClean = subset(Hitters, Salary != "NA")
# tmp = uzscale(HittersClean,0,c(2,"Salary") )
# detach("package:ISLR", unload = T)
```

```{r logit}

wine_reviews.df <-  read.csv("/Users/perry/Documents/Git/Intro To Data Science/edwinbet/data/wine_reviews.csv") %>%
  mutate(
    red = as.factor(ifelse(color == "red", 1, 0)),
    dom = as.factor(ifelse(country == "US", 1, 0)),
    p88 = ifelse(points > 88, 1, 0)
  ) %>%
  dplyr::select(
    points, price, year, red, dom, taster_following, comp_el, comp_lat, comp_lon, p88, taster_name
    )

wine_reviews.df <- na.omit(wine_reviews.df)

str(wine_reviews.df)

glm <- glm(formula = p88 ~ . -points, data = wine_reviews.df, family = binomial(link="logit"))
summary(glm)
exp(coef(glm))
```

```{r model eval}
cm <- reglass::confusion_matrix(glm)
cm
accuracy_glm <- (cm[1,1]+cm[2,2])/(cm[1,1] + cm[1,2] + cm[2,1] + cm[2,2])*100
accuracy_glm # 73.5% accurate

wine_reviews.df$prob <- predict(glm, type=c("response"))
roc <- pROC::roc(p88 ~ prob, data=wine_reviews.df)
roc # ROC-AUC value = 0.82
plot(roc) 
```

```{r predict}
# Referencing HW09 Q6

set.seed(1000)

# scale 
wine_reviews_z <- uzscale(wine_reviews.df, append=0, excl=c("p88"))

# sample and subset 
wine_reviews_sample <- sample(2, nrow(wine_reviews_z), replace = TRUE, prob = c(0.75, 0.25))
wine_reviews_train <- filter(wine_reviews_z, wine_reviews_sample == 1) 
wine_reviews_test <- filter(wine_reviews_z, wine_reviews_sample == 2)

# estimate logistic model using training data 
wine_reviews_logit <- glm(p88 ~ . -points, data = wine_reviews_train, family = binomial)
summary(wine_reviews_logit)

wine_reviews_logit$xlevels
wine_reviews_logit$xlevels[["taster_name"]] <- union(wine_reviews_logit$xlevels[["taster_name"]], levels(wine_reviews_test$taster_name))

# use cutoff rule to classify type 
wine_reviews_test <- wine_reviews_test %>%
  mutate(
    p88_logit_p = predict(wine_reviews_logit, wine_reviews_test, type = c("response")),
    p88_logit = ifelse(p88_logit_p > 0.5, 1, 0) 
  )

# calculate accuracy
t <- table(wine_reviews_test$p88, wine_reviews_test$p88_logit)
t
(t[1,1] + t[2,2]) / nrow(wine_reviews_test)
```